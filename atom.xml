<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>个人博客</title>
  
  <subtitle>记录日常的点滴</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://gkm0120.github.io/"/>
  <updated>2020-03-21T02:02:19.470Z</updated>
  <id>https://gkm0120.github.io/</id>
  
  <author>
    <name>戈孔明</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Hill密码加密解密</title>
    <link href="https://gkm0120.github.io/2020/03/20/Hill%E5%AF%86%E7%A0%81%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86/"/>
    <id>https://gkm0120.github.io/2020/03/20/Hill%E5%AF%86%E7%A0%81%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86/</id>
    <published>2020-03-20T14:39:30.000Z</published>
    <updated>2020-03-21T02:02:19.470Z</updated>
    
    <content type="html"><![CDATA[<h4 id="希尔密码加密解密原理"><a href="#希尔密码加密解密原理" class="headerlink" title="希尔密码加密解密原理:"></a>希尔密码加密解密原理:</h4><p>&emsp;&emsp;希尔密码是运用基本矩阵论原理的替换密码。每个字母当作26进制数字：A=0，B=1…一串字母当成n维向量，跟一个n×n的矩阵相乘，再将得出的结果MOD 26。注意用作加密的矩阵（即密钥）必须是可逆的，否则就不可能译码。只有矩阵的行列式和26互质，才是可逆的。</p><h4 id="1、产生随机矩阵，输入明文，产生密文"><a href="#1、产生随机矩阵，输入明文，产生密文" class="headerlink" title="1、产生随机矩阵，输入明文，产生密文"></a>1、产生随机矩阵，输入明文，产生密文</h4><pre><code class="C++">//Hill密码/*理解算法最重要，最好自己动手实现试试看，可以使用MFC写一个简单的交互界面*/#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;memory.h&gt;#include &lt;cstdlib&gt;#include &lt;ctime&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;using namespace std;//定义一些常变量const int M = 26;   //定义集合{a,b,...,z}的26个英文字母//行和列均为5const int ROW = 5;const int COL = 5;//定义5*5的加密矩阵int K[ROW][COL];//定义5*5的解密矩阵int D[ROW][COL];int P[ROW];  //明文单元int C[ROW];  //密文单元int F[ROW];  //密文解密后的单元//三元组gcd(a,b) = ax + by = dstruct GCD{    int x;    int y;    int d;};class Hill_Cipher{public:    //产生随机矩阵    void random_Matrix();    //求矩阵的行列式    int Det(int matrix[ROW][ROW],int row);    //求两个数的最大公约数    int gcd(int a,int b);    /*     *判断矩阵K是否在模26的情况下可逆     *因为矩阵在模26的情形下存在可逆矩阵的充分必要条件是     *gcd(det K,26) = 1     */    bool Inverse(int matrix[ROW][ROW]);    //矩阵相乘    void multiphy(int matrix[ROW][ROW],int p[ROW],int row);    //求出伴随矩阵    void adjoint_matrix(int matrix[ROW][ROW],int row);    //将明文加密为密文    string encryption(string plaintext);    //将密文解密为明文(为了辨识清楚,我们统一以小写字母作为明文,大写字母作为密文)    string deciphering(string ciphertext);    //欧几里得算法求模的逆    GCD extended_Euclid(int a,int b);    //模逆运算    int inverse(int a,int m);    //由于C++不存在负数取模的内置函数,现在自己设定一个    //定义一个模M的值    int Mod(int a);};void Hill_Cipher::random_Matrix(){    int i,j;    for(i = 0;i &lt; ROW;i++)    {        for(j = 0;j &lt; COL;j++)        {            K[i][j] = rand() % 26;  //产生一个5*5模26的矩阵        }    }}//求矩阵的行列式int Hill_Cipher::Det(int matrix[ROW][ROW],int row){    int i,j;    int cofa[ROW][ROW];            //用于存放余子阵    int l;   //l为所递归的余子阵的行    int p = 0,q = 0;    int sum=0;    //由于行和列相同(方阵),所以行列式的值一定存在,故不需要判断是否为方阵    //递归基    if(row == 1)        return matrix[0][0];   for(i = 0;i &lt; row; i++)   {     for(l = 0;l &lt; row - 1;l++)     {       if(l &lt; i)           p=0;       else           p=1;       for(j = 0;j&lt; row - 1;j++)       {         cofa[l][j] = matrix[l + p][j + 1];       }     }     //相当于(-1)^i     if(i % 2 == 0)         q=1;     else         q=(-1);     sum = sum + matrix[i][0] * q * Det(cofa,row - 1);   }   return sum;}//求两个数的最大公约数int Hill_Cipher::gcd(int a,int b){    int temp;    //交换两个数的大小,使得a为较大数    if(a &lt; b)    {        temp = a;        a = b;        b = temp;    }    while(a % b)    {        temp = b;        b = a % b;        a = temp;    }    return b;}/* *判断矩阵K是否在模26的情况下可逆 *因为矩阵在模26的情形下存在可逆矩阵的充分必要条件是 *gcd(det K,26) = 1 */bool Hill_Cipher::Inverse(int matrix[ROW][ROW]){    if(gcd(Det(matrix,ROW),M) == 1)        return true;    else        return false;}void Hill_Cipher::multiphy(int matrix[ROW][ROW],int p[ROW],int row){    int i,j;    //先将密文单元清零    memset(C,0,sizeof(C));    for(i = 0;i &lt; ROW;i++)    {        for(j = 0;j &lt; ROW;j++)        {            C[i] += P[j] * K[j][i];        }    }}//将明文加密为密文string Hill_Cipher::encryption(string plaintext){    int i;    string ciphertext;    //将字符串转化为明文数组    for(i = 0;i &lt; ROW;i++)    {        P[i] = plaintext[i] - &#39;a&#39;;    }    multiphy(K,P,ROW);    //将密文数组转化为密文    for(i = 0;i &lt; ROW;i++)        //这里先将其模26,再翻译为对应的字母    {        C[i] =Mod(C[i]);        ciphertext += C[i] + &#39;A&#39;;    }    return ciphertext;}//求出伴随矩阵void Hill_Cipher::adjoint_matrix(int matrix[ROW][ROW],int row){    int i,j,k,l;    int p,q;    p = q = 0;    int temp[ROW][ROW];    for(i = 0;i &lt; ROW;i++)    {        for(j = 0;j &lt; ROW;j++)        {            for(k = 0;k &lt; ROW - 1;k++)            {                if(k &lt; i)                    p = 0;                else                    p = 1;                for(l = 0;l &lt; ROW - 1;l++)                {                    if(l &lt; j)                        q = 0;                    else                        q = 1;                    temp[k][l] = matrix[k+p][l+q];                }            }            D[j][i] = (int)pow(-1,(double)i+j)*Det(temp,ROW-1);            D[j][i] = Mod(D[j][i]);        }    }}//将密文解密为明文(为了辨识清楚,我们统一以小写字母作为明文,大写字母作为密文)string Hill_Cipher::deciphering(string ciphertext){    //求出矩阵的逆    string text;    int determinant = Det(K,ROW);    int inver = inverse(determinant,26);    adjoint_matrix(K,ROW);   //伴随矩阵    cout &lt;&lt; &quot;行列式的值: &quot; &lt;&lt; determinant &lt;&lt; endl;    int i,j;    memset(F,0,sizeof(F));    for(i = 0;i &lt; ROW;i++)    {        for(j = 0;j &lt; ROW;j++)        {            F[i] += C[j] * D[j][i];        }        F[i] *= inver;        F[i] = Mod(F[i]);   //算到的结果要模去26    }    for(i = 0;i &lt; ROW;i++)        text += F[i] + &#39;a&#39;;    return text;}GCD Hill_Cipher::extended_Euclid(int a,int b){    GCD aa,bb;    if(b == 0)    {        aa.x = 1;        aa.y = 0;        aa.d = a;        return aa;    }    else    {        bb = extended_Euclid(b,a%b);        aa.x = bb.y;        aa.y = bb.x - (a / b) * bb.y;        aa.d = bb.d;    }    return aa;}int Hill_Cipher::inverse(int a,int m){    GCD aa;    aa = extended_Euclid(a,m);    return aa.x;}int Hill_Cipher::Mod(int a){    return a &gt;= 0 ? a % M : (M + a % M);}int main(){    int i,j;    Hill_Cipher hh;    cout &lt;&lt; &quot;使用希尔密码进行消息的加解密:&quot; &lt;&lt; endl;    //srand()函数产生一个以当前时间开始的随机种子.以保证每次产生的随机数矩阵都不相同    srand((unsigned)time(0));    hh.random_Matrix();    while(!hh.Inverse(K))    {        hh.random_Matrix();    }    cout &lt;&lt; &quot;随机产生5*5的矩阵:&quot; &lt;&lt; endl;    for(i = 0;i &lt; ROW;i++)    {        for(j = 0;j &lt; COL;j++)        {            printf(&quot;%2d  &quot;,K[i][j]);        }        cout &lt;&lt; endl;    }    cout &lt;&lt; &quot;该矩阵模26可逆,因此可以作为密钥.&quot; &lt;&lt; endl;    cout &lt;&lt; endl;    //利用所选密钥，对给定的5元明文信息进行加解密    string plaintext,ciphertext;    cout &lt;&lt; &quot;请输入5元明文信息:&quot; &lt;&lt; endl;    cin &gt;&gt; plaintext;    ciphertext = hh.encryption(plaintext);    cout &lt;&lt; endl;    cout &lt;&lt; &quot;该明文通过希尔密码法加密过后,输出的密文消息为:&quot; &lt;&lt; endl;    cout &lt;&lt; ciphertext &lt;&lt; endl;    cout &lt;&lt; endl;    cout &lt;&lt; &quot;***输入0:退出          ***&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;***输入1:查看明文空间对***&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;***输入2:查看密文空间对***&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;***输入3:查看密钥      ***&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;***输入4:将消息解密    ***&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;***输入5:查看菜单      ***&quot; &lt;&lt; endl;    char c;    while(cin &gt;&gt; c)    {        if(c == &#39;0&#39;)        {            cout &lt;&lt; endl;            cout &lt;&lt; &quot;退出&quot; &lt;&lt; endl;            break;        }        else if(c == &#39;1&#39;)        {            cout &lt;&lt; &quot;明文空间:&quot; &lt;&lt; endl;            for(i = 0;i &lt; ROW;i++)                cout &lt;&lt; P[i] &lt;&lt; &quot;  &quot;;            cout &lt;&lt; endl;            cout &lt;&lt; endl;        }        else if(c == &#39;2&#39;)        {            cout &lt;&lt; &quot;密文空间:&quot; &lt;&lt; endl;            for(i = 0;i &lt; ROW;i++)                cout &lt;&lt; C[i] &lt;&lt; &quot;  &quot;;            cout &lt;&lt; endl;            cout &lt;&lt; endl;        }        else if(c == &#39;3&#39;)        {            cout &lt;&lt; &quot;密钥:&quot; &lt;&lt; endl;            for(i = 0;i &lt; ROW;i++)            {                for(j = 0;j &lt; ROW;j++)                {                    printf(&quot;%2d  &quot;,K[i][j]);                }                cout &lt;&lt; endl;            }            cout &lt;&lt; endl;        }        else if(c == &#39;4&#39;)        {            hh.adjoint_matrix(K,ROW);            string ss;            ss = hh.deciphering(ciphertext);            cout &lt;&lt; &quot;该密文解密过后,显示的原来的明文消息:&quot; &lt;&lt; endl;            cout &lt;&lt; ss &lt;&lt; endl;            cout &lt;&lt; endl;        }        else        {            cout &lt;&lt; &quot;***输入0:退出          ***&quot; &lt;&lt; endl;            cout &lt;&lt; &quot;***输入1:查看明文空间对***&quot; &lt;&lt; endl;            cout &lt;&lt; &quot;***输入2:查看密文空间对***&quot; &lt;&lt; endl;            cout &lt;&lt; &quot;***输入3:查看密钥      ***&quot; &lt;&lt; endl;            cout &lt;&lt; &quot;***输入4:将消息解密    ***&quot; &lt;&lt; endl;            cout &lt;&lt; &quot;***输入5:查看菜单      ***&quot; &lt;&lt; endl;        }    }    return 0;}</code></pre><h4 id="2、输入密钥矩阵，输入明文，产生密文"><a href="#2、输入密钥矩阵，输入明文，产生密文" class="headerlink" title="2、输入密钥矩阵，输入明文，产生密文"></a>2、输入密钥矩阵，输入明文，产生密文</h4><pre><code class="C++">#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#define N 100using namespace std;//按第一列展开，递归计算行列式值int caluDet(int n, int **a){    int i, r, c, p, q;    int sum=0;    if(n==1)        return a[0][0];    int **det = (int**)malloc((n-1)*sizeof(int*));    for(i=0; i&lt;(n-1); i++)        det[i] = (int*)malloc((n-1)*sizeof(int));    for(i=0; i&lt;n; i++) {        for(r=0; r&lt;n-1; r++) {         //子矩阵 (n-1) 行            if(r&lt;i) p = 0;              //当前行 a[r] 赋值给子矩阵            else    p = 1;             //下一行 a[r+1] 赋值给子矩阵            for(c=0; c&lt;n-1; c++)        //子矩阵 (n-1) 列                det[r][c] = a[r+p][c+1];        }        if(i%2==0) q = 1;               //由于是对第一列展开，即 [i][0]        else q = -1;        sum = sum + a[i][0] * q*caluDet(n-1,det);    }    for(i=0; i&lt;(n-1); i++)        free(det[i]);    free(det);    return sum;}//初始化明文void initPlain(char p[], int n){    int i, len, t;    cout &lt;&lt; &quot;输入明文p: \n&quot;;    getchar(); gets(p);    for(i=0; i&lt;strlen(p); i++) {        if (p[i] ==&#39; &#39;)             //跳过空格            strcpy(p+i,p+i+1);        if (p[i]&gt;=&#39;a&#39; &amp;&amp; p[i]&lt;=&#39;z&#39;)  //小写转大写            p[i] -= 32;    }    len = strlen(p);    t = len%n&gt;0 ? n-len%n : len%n;    while(t--)     //若最后一个明文对字母不足，则添加与最后一个明文相同的字母        p[strlen(p)] = p[len-1];    p[strlen(p)] = &#39;\0&#39;;    cout &lt;&lt;&quot;\nInit P: &quot; &lt;&lt; p &lt;&lt; endl;}//输入密钥矩阵void keyMatrix(int **det, int len){    int i, j;    for(i=0; i&lt;len; i++)        for(j=0; j&lt;len; j++)            cin &gt;&gt; det[i][j];}//分组、矩阵乘法void matricMultiply(char p[], char c[], int **key, int n){    int i,j,k;    int len = strlen(p);    for(i=0; i&lt;strlen(p)/n; i++){       //明文每 n 个作为一行        for(j=0; j&lt;n; j++){             //明文的列、密钥矩阵的列            for(k=0; k&lt;n; k++){         //密钥矩阵的行                c[n*i+j] += ((p[n*i+k]-&#39;A&#39;) * key[k][j]) % 26;            }            c[n*i+j] = c[n*i+j] % 26 + &#39;A&#39;;            //cout &lt;&lt; (int)c[n*i+j] &lt;&lt; &quot; &quot;;        }    }    cout &lt;&lt; &quot;Cipher: &quot; &lt;&lt; c &lt;&lt; endl;}int main(){    int i, j, n, len;    char p[N]={0}, c[N]={0};    cout &lt;&lt; &quot;输入密钥的阶：\n&quot;;    cin &gt;&gt; n;    //为密钥矩阵申请内存空间    int **key = (int**)malloc(n*sizeof(int*));    for(i=0; i&lt;n; i++)        key[i] = (int*)malloc(n*sizeof(int));    //获取密钥矩阵并验证是否可逆    cout &lt;&lt; &quot;输入&quot; &lt;&lt;n&lt;&lt;&quot;阶密钥矩阵：\n&quot;;    keyMatrix(key,n);    while(!caluDet(n, key)) {        cout &lt;&lt; &quot;密钥不存在逆矩阵! 请重新输入：\n&quot;;        keyMatrix(key,n);    }    //初始化明文    initPlain(p, n);    len = strlen(p);    //各组明文乘密钥矩阵加密    matricMultiply (p, c, key, n);    //释放密钥矩阵的内存空间    for(i=0; i&lt;n; i++)        free(key[i]);    free(key);    return 0;}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;希尔密码加密解密原理&quot;&gt;&lt;a href=&quot;#希尔密码加密解密原理&quot; class=&quot;headerlink&quot; title=&quot;希尔密码加密解密原理:&quot;&gt;&lt;/a&gt;希尔密码加密解密原理:&lt;/h4&gt;&lt;p&gt;&amp;emsp;&amp;emsp;希尔密码是运用基本矩阵论原理的替换密码。每个字母
      
    
    </summary>
    
    
      <category term="Hill" scheme="https://gkm0120.github.io/categories/Hill/"/>
    
    
      <category term="hill" scheme="https://gkm0120.github.io/tags/hill/"/>
    
  </entry>
  
  <entry>
    <title>【OpenGL】Sierpinski 镂垫程序</title>
    <link href="https://gkm0120.github.io/2020/03/19/%E3%80%90OpenGL%E3%80%91Sierpinski-%E9%95%82%E5%9E%AB%E7%A8%8B%E5%BA%8F/"/>
    <id>https://gkm0120.github.io/2020/03/19/%E3%80%90OpenGL%E3%80%91Sierpinski-%E9%95%82%E5%9E%AB%E7%A8%8B%E5%BA%8F/</id>
    <published>2020-03-19T10:12:31.000Z</published>
    <updated>2020-03-21T02:02:45.569Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;Sierpinski镂垫是一个非常有趣的图案，有着悠久的历史， 在分形几何中等领域里引起了人们极大地兴趣， 是用递归和随机方式定义的几何形状。生成算法如下：<br>&emsp;&emsp;第一步：在三角形内部随机选取一个点作为初始点；<br>&emsp;&emsp;第二步：在三角形的3个顶点中随机选取一个，求出该顶点与初始点连线的中点，画出该中点；<br>&emsp;&emsp;第三步：将第二步中的中点作为初始点，循环第二步；</p><h4 id="1、绘制二维Sierpinski镂垫"><a href="#1、绘制二维Sierpinski镂垫" class="headerlink" title="1、绘制二维Sierpinski镂垫"></a>1、绘制二维Sierpinski镂垫</h4><pre><code>/*使用随机选择的顶点和中点绘制二维Sierpinski镂垫*/#include &lt;windows.h&gt;#include &lt;GL/glut.h&gt;void myinit(){  glClearColor(1.0,1.0,1.0,1.0);/*白色背景*/  glColor3f(1.0,0.0,0.0);/*红色*/  glMatrixMode(GL_PROJECTION);  glLoadIdentity();  gluOrtho2D(0.0,50.0,0.0,50.0);/*50×50相机坐标窗口与原点左下角*/  glMatrixMode(GL_MODELVIEW);}void display(){  GLfloat vertices[3][2]={{0.0,0.0},{25.0,50.0},{50.0,0.0}};  int j,k;  int rand();/*产生随机数*/  GLfloat p[2]={7.5,5.0};/*在三角形内任意初始点*/  glClear(GL_COLOR_BUFFER_BIT);/*清理窗口*/  glBegin(GL_POINTS);/*产生5000个新点*/  for(k=0;k&lt;5000;k++)  {    j=rand()%3;/*随机选择一个顶点*/    /*计算点位于选定顶点和旧点之间*/    p[0]=(p[0]+vertices[j][0])/2.0;    p[1]=(p[1]+vertices[j][1])/2.0;    /*画新点*/    glVertex2fv(p);  }  glEnd();  glFlush();/*清除缓冲帧*/}int main(int argc,char *argv[]){  glutInit(&amp;argc,argv);/*标准的GLUT初始化*/  glutInitDisplayMode(GLUT_SINGLE | GLUT_RGB);/*默认设置*/  glutInitWindowSize(500,500);/*500×500像素窗口*/  glutInitWindowPosition(0,0);/*将窗口放在左下角*/  glutCreateWindow(&quot;Sierpinski Gasket&quot;);/*窗口名*/  glutDisplayFunc(display);/*窗口打开时调用的显示回调*/  myinit();/*设置属性*/  glutMainLoop();/*进入事件循环*/}</code></pre><h4 id="2、生成-Sierpinski-镂垫的递归程序"><a href="#2、生成-Sierpinski-镂垫的递归程序" class="headerlink" title="2、生成 Sierpinski 镂垫的递归程序"></a>2、生成 Sierpinski 镂垫的递归程序</h4><pre><code>/* 通过细分三角形的方法生成Sierpinski镂垫 *//* 通过命令行输入递归的次数 */#include &lt;GL/glut.h&gt;#include&lt;stdlib.h&gt;/* 初始的三角形 */GLfloat v[3][2]={{-1.0, -0.58}, {1.0, -0.58}, {0.0, 1.15}};int n;void triangle( GLfloat *a, GLfloat *b, GLfloat *c)/* 定义某个三角形 */{ glVertex2fv(a); glVertex2fv(b); glVertex2fv(c);}void divide_triangle(GLfloat *a, GLfloat *b, GLfloat *c, int m){/* 基于某个顶点的数量对三角形进行细分处理 */ GLfloat v0[2], v1[2], v2[2]; int j; if(m&gt;0) { for(j=0; j&lt;2; j++) v0[j]=(a[j]+b[j])/2; for(j=0; j&lt;2; j++) v1[j]=(a[j]+c[j])/2; for(j=0; j&lt;2; j++) v2[j]=(b[j]+c[j])/2; divide_triangle(a, v0, v1, m-1); divide_triangle(c, v1, v2, m-1); divide_triangle(b, v2, v0, m-1); } else triangle(a,b,c); /* 递归结束时绘制三角形 */}void display(void){     glClear(GL_COLOR_BUFFER_BIT);         glBegin(GL_TRIANGLES);         divide_triangle(v[0], v[1], v[2], n);         glEnd();     glFlush();}void myinit(){     glMatrixMode(GL_PROJECTION);     glLoadIdentity();     gluOrtho2D(-2.0, 2.0, -2.0, 2.0);     glMatrixMode(GL_MODELVIEW);     glClearColor(1.0, 1.0, 1.0, 1.0);     glColor3f(0.0,0.0,0.0);}main(int argc, char **argv){     n=atoi(argv[1]);    /* 或者在此输入三角形细分的步数 */     glutInit(&amp;argc, argv);     glutInitDisplayMode(GLUT_SINGLE | GLUT_RGB);     glutInitWindowSize(500, 500);     glutCreateWindow(&quot;Sierpinski Gasket&quot;);     glutDisplayFunc(display);         myinit();     glutMainLoop();}</code></pre><h4 id="3、三维-Sierpinski-镂垫的递归程序"><a href="#3、三维-Sierpinski-镂垫的递归程序" class="headerlink" title="3、三维 Sierpinski 镂垫的递归程序"></a>3、三维 Sierpinski 镂垫的递归程序</h4><pre><code>/* 通过递归细分四面体方法生成Sierpinski镂垫 *//* 通过命令行递归的次数 */#include &lt;stdlib.h&gt;#include &lt;GL/glut.h&gt;/* 初始的四面体 */GLfloat v[4][3]={{0.0, 0.0, 1.0},{0.0, 0.942809, -0.33333},  {-0.816497, -0.471405, -0.333333},{0.816497, -0.471405, -0.333333}};GLfloat colors[4][3]={{1.0,0.0,0.0},{0.0,1.0,0.0},{0.0,0.0,1.0},{0.0,0.0,0.0}};int n;void triangle( GLfloat *va, GLfloat *vb, GLfloat *vc){ glVertex3fv(va); glVertex3fv(vb); glVertex3fv(vc);}void tetra(GLfloat *a, GLfloat *b, GLfloat *c, GLfloat *d){ glColor3fv(colors[0]); triangle(a,b,c); glColor3fv(colors[1]); triangle(a,c,d); glColor3fv(colors[2]); triangle(a,d,b); glColor3fv(colors[3]); triangle(b,d,c);}void divide_tetra(GLfloat *a, GLfloat *b, GLfloat *c, GLfloat *d, int m){ GLfloat mid[6][3]; int j; if(m&gt;0) {   /* 计算六个中点 */ for(j=0; j&lt;3; j++) mid[0][j]=(a[j]+b[j])/2; for(j=0; j&lt;3; j++) mid[1][j]=(a[j]+c[j])/2; for(j=0; j&lt;3; j++) mid[2][j]=(a[j]+d[j])/2; for(j=0; j&lt;3; j++) mid[3][j]=(b[j]+c[j])/2; for(j=0; j&lt;3; j++) mid[4][j]=(c[j]+d[j])/2; for(j=0; j&lt;3; j++) mid[5][j]=(b[j]+d[j])/2;   /* 通过细分生成四个四面体 */ divide_tetra(a,mid[0],mid[1],mid[2], m-1); divide_tetra(mid[0],b,mid[3],mid[5], m-1); divide_tetra(mid[1],mid[3],c,mid[4], m-1); divide_tetra(mid[2],mid[4],d,mid[5], m-1); } else   tetra(a,b,c,d); /* 递归结束时绘制四面体 */}void display(void){ glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT); glBegin(GL_TRIANGLES);     divide_tetra(v[0],v[1],v[2],v[3],n);     glEnd();     glFlush();}void myReshape(int w, int h){     glViewport(0, 0, w, h);     glMatrixMode(GL_PROJECTION);     glLoadIdentity();     if (w &lt;= h)     glOrtho(-2.0, 2.0, -2.0 * (GLfloat) h / (GLfloat) w, 2.0 * (GLfloat) h / (GLfloat) w, -10.0, 10.0); else     glOrtho(-2.0 * (GLfloat) w / (GLfloat) h, 2.0 * (GLfloat) w / (GLfloat) h, -2.0, 2.0, -10.0, 10.0); glMatrixMode(GL_MODELVIEW); glutPostRedisplay();}main(int argc, char **argv){ n=atoi(argv[1]);  /* 或者在此处输入四面体细分的步数 */ glutInit(&amp;argc, argv); glutInitDisplayMode(GLUT_SINGLE | GLUT_RGB | GLUT_DEPTH); glutInitWindowSize(500, 500); glutCreateWindow(&quot;3D Gasket&quot;); glutReshapeFunc(myReshape); glutDisplayFunc(display); glEnable(GL_DEPTH_TEST); glClearColor (1.0, 1.0, 1.0, 1.0); glutMainLoop();}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&amp;emsp;&amp;emsp;Sierpinski镂垫是一个非常有趣的图案，有着悠久的历史， 在分形几何中等领域里引起了人们极大地兴趣， 是用递归和随机方式定义的几何形状。生成算法如下：&lt;br&gt;&amp;emsp;&amp;emsp;第一步：在三角形内部随机选取一个点作为初始点；&lt;br&gt;&amp;ems
      
    
    </summary>
    
    
      <category term="OpengL" scheme="https://gkm0120.github.io/categories/OpengL/"/>
    
    
      <category term="opengl" scheme="https://gkm0120.github.io/tags/opengl/"/>
    
  </entry>
  
  <entry>
    <title>【OpenGL】球体的细分逼近程序</title>
    <link href="https://gkm0120.github.io/2020/03/18/%E3%80%90OpenGL%E3%80%91%E7%90%83%E4%BD%93%E7%9A%84%E7%BB%86%E5%88%86%E9%80%BC%E8%BF%91%E7%A8%8B%E5%BA%8F/"/>
    <id>https://gkm0120.github.io/2020/03/18/%E3%80%90OpenGL%E3%80%91%E7%90%83%E4%BD%93%E7%9A%84%E7%BB%86%E5%88%86%E9%80%BC%E8%BF%91%E7%A8%8B%E5%BA%8F/</id>
    <published>2020-03-18T08:42:54.000Z</published>
    <updated>2020-03-21T02:02:56.500Z</updated>
    
    <content type="html"><![CDATA[<pre><code>/* 通过递归细分四面体生成球体，三种显示模式：线性框、均匀着色，插值着色 *//* 该程序在init()函数中还定义了材质和光源 *//* mode 0 = 线性框, mode 1 = 均与着色,mode 3 = 插值着色 */#include &lt;stdlib.h&gt;#include&lt;math.h&gt;#include &lt;GL/glut.h&gt;typedef float point[4];/* 初始化四面体 */point v[]={{0.0, 0.0, 1.0}, {0.0, 0.942809, -0.33333},    {-0.816497, -0.471405, -0.333333}, {0.816497, -0.471405, -0.333333}};GLfloat theta[] = {0.0,0.0,0.0};int n;int mode;void triangle( point a, point b, point c)/*利用GL_LINR_LOOP模式显示一个三角形的线性图，定义一个法向量用于均匀着色，定义三个法向量用于插值着色*/{ if (mode==0)  glBegin(GL_LINE_LOOP); else  glBegin(GL_POLYGON);    if(mode==1) glNormal3fv(a);    if(mode==2) glNormal3fv(a);     glVertex3fv(a);    if(mode==2) glNormal3fv(b);    glVertex3fv(b);    if(mode==2) glNormal3fv(c);    glVertex3fv(c); glEnd();}void normal(point p){/* 矢量归一化 */double sqrt(double d);float d = 0.0;int i;for (i = 0; i &lt; 3; i++) d += p[i] * p[i];d = sqrt(d);if (d &gt; 0.0)    for (i = 0; i &lt; 3; i++) p[i] /= d;}void divide_triangle(point a, point b, point c, int m){/* 基于顶点数目细分三角形，应用右手规则生成对象的外向表面 */ point v1, v2, v3; int j; if(m&gt;0) {    for(j=0; j&lt;3; j++) v1[j]=a[j]+b[j];    normal(v1);    for(j=0; j&lt;3; j++) v2[j]=a[j]+c[j];    normal(v2);    for(j=0; j&lt;3; j++) v3[j]=b[j]+c[j];    normal(v3);    divide_triangle(a, v1, v2, m-1);    divide_triangle(c, v2, v3, m-1);    divide_triangle(b, v3, v1, m-1);    divide_triangle(v1, v3, v2, m-1); } else triangle(a,b,c); /* 递归结束时绘制三角形 */}void tetrahedron(int m){/* 对四面体的表面应用三角细分 */ divide_triangle(v[0], v[1], v[2], m); divide_triangle(v[3], v[2], v[1], m); divide_triangle(v[0], v[3], v[1], m); divide_triangle(v[0], v[2], v[3], m);}void display(){/* 逐一显示这三种模式下的四面体 */ glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT); glLoadIdentity(); mode=0; tetrahedron(n); mode=1; glTranslatef(-2.0, 0.0, 0.0); tetrahedron(n); mode=2; glTranslatef(4.0, 0.0, 0.0); tetrahedron(n); glFlush();}void myReshape(int w, int h){ glViewport(0, 0, w, h); glMatrixMode(GL_PROJECTION); glLoadIdentity(); if (w &lt;= h)    glOrtho(-4.0, 4.0, -4.0 * (GLfloat) h / (GLfloat) w,        4.0 * (GLfloat) h / (GLfloat) w, -10.0, 10.0); else    glOrtho(-4.0 * (GLfloat) w / (GLfloat) h,        4.0 * (GLfloat) w / (GLfloat) h, -4.0, 4.0, -10.0, 10.0); glMatrixMode(GL_MODELVIEW); display();}void myinit(){    GLfloat mat_specular[]={1.0, 1.0, 1.0, 1.0};    GLfloat mat_diffuse[]={1.0, 1.0, 1.0, 1.0};    GLfloat mat_ambient[]={1.0, 1.0, 1.0, 1.0};    GLfloat mat_shininess={100.0};    GLfloat light_ambient[]={0.0, 0.0, 0.0, 1.0};    GLfloat light_diffuse[]={1.0, 1.0, 1.0, 1.0};    GLfloat light_specular[]={1.0, 1.0, 1.0, 1.0};/* 为光源0分别设置环境光、漫反射光和镜面反射光的参数 */    glLightfv(GL_LIGHT0, GL_AMBIENT, light_ambient);    glLightfv(GL_LIGHT0, GL_DIFFUSE, light_diffuse);    glLightfv(GL_LIGHT0, GL_SPECULAR, light_specular);/* 为所有三角形正面定义材质属性 */    glMaterialfv(GL_FRONT, GL_SPECULAR, mat_specular);    glMaterialfv(GL_FRONT, GL_AMBIENT, mat_ambient);    glMaterialfv(GL_FRONT, GL_DIFFUSE, mat_diffuse);    glMaterialf(GL_FRONT, GL_SHININESS, mat_shininess);    glShadeModel(GL_SMOOTH); /* 开启平滑着色 */    glEnable(GL_LIGHTING); /* 开启光照 */    glEnable(GL_LIGHT0); /* 开启光源0 */    glEnable(GL_DEPTH_TEST); /* 开启z-buffer */    glClearColor (1.0, 1.0, 1.0, 1.0);    glColor3f (0.0, 0.0, 0.0);}main(int argc, char **argv){    n=4;//n=1,2,3,4,5,6……  //n=atoi(argv[1]);//直接运行会出错，具体参照BookCode的此处源码处理方案    glutInit(&amp;argc, argv);    glutInitDisplayMode(GLUT_SINGLE | GLUT_RGB | GLUT_DEPTH);    glutInitWindowSize(500, 500);    glutCreateWindow(&quot;sphere&quot;);    myinit();    glutReshapeFunc(myReshape);    glutDisplayFunc(display);    glutMainLoop();}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;pre&gt;&lt;code&gt;/* 通过递归细分四面体生成球体，三种显示模式：线性框、均匀着色，插值着色 */
/* 该程序在init()函数中还定义了材质和光源 */
/* mode 0 = 线性框, mode 1 = 均与着色,
mode 3 = 插值着色 */
#include &amp;
      
    
    </summary>
    
    
      <category term="OpengL" scheme="https://gkm0120.github.io/categories/OpengL/"/>
    
    
      <category term="opengl" scheme="https://gkm0120.github.io/tags/opengl/"/>
    
  </entry>
  
  <entry>
    <title>【Git】Git和Node.js重新安装</title>
    <link href="https://gkm0120.github.io/2020/03/17/%E3%80%90Git%E3%80%91Git%E5%92%8CNode-js%E9%87%8D%E6%96%B0%E5%AE%89%E8%A3%85/"/>
    <id>https://gkm0120.github.io/2020/03/17/%E3%80%90Git%E3%80%91Git%E5%92%8CNode-js%E9%87%8D%E6%96%B0%E5%AE%89%E8%A3%85/</id>
    <published>2020-03-17T05:07:25.000Z</published>
    <updated>2020-03-21T02:01:38.858Z</updated>
    
    <content type="html"><![CDATA[<p>一、Git安装教程<br>下载地址：<a href="https://git-scm.com/downloads" target="_blank" rel="noopener">https://git-scm.com/downloads</a><br>1、点击next<br>2、根据自己想安装软件的位置来选者路径(我这里选择的是D:\blog)<br>3、安装配置文件，自己需要选择<br>4、不创建启动文件夹（勾选Don’t create a Star Menu folder）<br>5、选择默认编辑器<br>6、点击Next(Git from the command…)<br>7、使用默认设置就行(use the OpenSSL libuary)<br>8、默认(Checkout Windows-style,…)<br>9、在终端模拟器选择页面，默认即可，配置后Git<br>10、最后配置Git额外选择默认安装<br>11、安装完成（鼠标右键出现Git GUI Here和Git<br> Bash Here）</p><p>二、Node.js安装<br>下载地址：<a href="https://nodejs.org/en/download/" target="_blank" rel="noopener">https://nodejs.org/en/download/</a><br>1、下载完成后，开始安装<br>2、接受协议<br>3、根据自己要安装的地方选择安装目录(我这里选择D:\blog\node.js路径下)<br>4、选择安装项，一般默认<br>5、点击“Install”按钮，开始安装，完成安装<br>6、检验：<br>    1.node -v 查看 node 版本<br>    2.npm -v 查看 npm 版本</p><p>三、环境配置<br>设置环境变量，“我的电脑”-右键-“属性”-“高级系统设置”-“高级”-“环境变量”<br>在用户变量里选择Path，点击新建，在弹出的框中点击新建，然后在其中添加D:\blog\Node.js\node_modules</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一、Git安装教程&lt;br&gt;下载地址：&lt;a href=&quot;https://git-scm.com/downloads&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://git-scm.com/downloads&lt;/a&gt;&lt;br&gt;1、点击next&lt;br
      
    
    </summary>
    
    
      <category term="nodejs" scheme="https://gkm0120.github.io/categories/nodejs/"/>
    
    
      <category term="git" scheme="https://gkm0120.github.io/tags/git/"/>
    
      <category term="nodejs" scheme="https://gkm0120.github.io/tags/nodejs/"/>
    
  </entry>
  
  <entry>
    <title>【Git】Git常见报错及处理方法</title>
    <link href="https://gkm0120.github.io/2020/03/16/%E3%80%90Git%E3%80%91Git%E5%B8%B8%E8%A7%81%E6%8A%A5%E9%94%99%E5%8F%8A%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95/"/>
    <id>https://gkm0120.github.io/2020/03/16/%E3%80%90Git%E3%80%91Git%E5%B8%B8%E8%A7%81%E6%8A%A5%E9%94%99%E5%8F%8A%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95/</id>
    <published>2020-03-16T06:03:03.000Z</published>
    <updated>2020-03-21T02:02:07.489Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Git常见报错及处理方法"><a href="#Git常见报错及处理方法" class="headerlink" title="Git常见报错及处理方法"></a>Git常见报错及处理方法</h2><h5 id="一、如果输入-git-remote-add-origin-git-github-com-gkm0120（github帐号名）-gitdemo（项目名）-git"><a href="#一、如果输入-git-remote-add-origin-git-github-com-gkm0120（github帐号名）-gitdemo（项目名）-git" class="headerlink" title="一、如果输入$ git remote add origin git@github.com:gkm0120（github帐号名）/gitdemo（项目名）.git"></a>一、如果输入$ git remote add origin <a href="mailto:git@github.com">git@github.com</a>:gkm0120（github帐号名）/gitdemo（项目名）.git</h5><p>提示出错信息：fatal: remote origin already exists.<br>解决办法如下：<br>1、先输入$ git remote rm origin<br>2、再输入$ git remote add origin <a href="mailto:git@github.com">git@github.com</a>:gkm0120/gkm0120.github.io.git 就不会报错了！<br>3、如果输入$ git remote rm origin 还是报错的话，error: Could not remove config section ‘remote.origin’. 我们需要修改gitconfig文件的内容<br>4、找到你的github的安装路径，我的是C:/Users/gkm0120/.git<br>5、找到一个名为gitconfig的文件，打开它把里面的[remote “origin”]那一行删掉就好了！</p><h5 id="二、如果输入-ssh-T-git-github-com"><a href="#二、如果输入-ssh-T-git-github-com" class="headerlink" title="二、如果输入$ ssh -T git@github.com"></a>二、如果输入$ ssh -T <a href="mailto:git@github.com">git@github.com</a></h5><p>出现错误提示：Permission denied (publickey).因为新生成的key不能加入ssh就会导致连接不上github。<br>解决办法如下：<br>1、先输入$ ssh-agent，再输入$ ssh-add ~/.ssh/id_key，这样就可以了。<br>2、如果还是不行的话，输入ssh-add ~/.ssh/id_key 命令后出现报错Could not open a connection to your authentication agent.解决方法是key用Git Gui的ssh工具生成，这样生成的时候key就直接保存在ssh中了，不需要再ssh-add命令加入了，其它的user，token等配置都用命令行来做。<br>3、最好检查一下在你复制id_rsa.pub文件的内容时有没有产生多余的空格或空行，有些编辑器会帮你添加这些的。</p><h5 id="三、如果输入-git-push-origin-master"><a href="#三、如果输入-git-push-origin-master" class="headerlink" title="三、如果输入$ git push origin master"></a>三、如果输入$ git push origin master</h5><p>提示出错信息：error: failed to push some refs to ‘git@github.com:gkm0120/-.git’<br>错误分析：本地没有update到最新版本的项目（git上有README.md文件没下载下来）、本地直接push所以会出错。</p><p>解决办法如下（两种）：<br>第一种：<br>$ git pull –rebase origin master<br>……显示一串拉代码的英文，此时已经把github上最新的文件<br>然后在输入git push origin master,即可成功把本地的文件都上传到github上面去了<br>$ git push origin master</p><p>第二种：<br>1、先输入$ git pull origin master //先把远程服务器github上面的文件拉下来<br>2、再输入$ git push origin master<br>3、如果出现报错 fatal: Couldn’t find remote ref master或者fatal: ‘origin’ does not appear to be a git repository以及fatal: Could not read from remote repository.<br>4、则需要重新输入$ git remote add <a href="mailto:origingit@github.com">origingit@github.com</a>:gkm0120/gkm0120.github.io.git<br>使用git在本地创建一个项目的过程<br>$ makdir ~/hello-world //创建一个项目hello-world<br>$ cd ~/hello-world //打开这个项目<br>$ git init //初始化<br>$ touch README<br>$ git add README//更新README文件<br>$ git commit -m ‘first commit’ //提交更新，并注释信息“first commit”<br>$ git remote add origin <a href="mailto:git@github.com">git@github.com</a>:gkm0120/gkm0120.github.io.git //连接远程github项目<br>$ git push -u origin master //将本地项目更新到github项目上去</p><h5 id="四、场景：当我新建了一个项目时，使用git-clone之后，此时git-remote-v查看远程仓库为"><a href="#四、场景：当我新建了一个项目时，使用git-clone之后，此时git-remote-v查看远程仓库为" class="headerlink" title="四、场景：当我新建了一个项目时，使用git clone之后，此时git remote -v查看远程仓库为"></a>四、场景：当我新建了一个项目时，使用git clone之后，此时git remote -v查看远程仓库为</h5><p>$ git remote -v<br>origin  <a href="mailto:git@github.com">git@github.com</a>:gkm0120/gkm0120.github.io.git (fetch)<br>origin  <a href="mailto:git@github.com">git@github.com</a>:gkm0120/gkm0120.github.io.git (push)<br>然后给这个仓库起个新名字叫 gkm_git，此时我在git Bash提交代码时 git add .之前需要将 git remote -v的远程代码改成当前远程仓库的ssh地址；<br>解决方法（3种）：</p><ol><li>修改命令<br>git remte origin set-url URL</li><li>先删后加<br>git remote rm origin<br>git remote add origin <a href="mailto:git@github.com">git@github.com</a>:gkm0120/gkm_git.git</li><li>直接修改config文件<br>此时 git remote -v就知道该过来了<br>$ git remote -v<br>origin  <a href="mailto:git@github.com">git@github.com</a>:gkm0120/gkm0120.github.io.git (fetch)<br>origin  <a href="mailto:git@github.com">git@github.com</a>:gkm0120/gkm0120.github.io.git (push)</li></ol><p>参考链接：<a href="https://blog.csdn.net/Umbrella_Um/article/details/97271486" target="_blank" rel="noopener">https://blog.csdn.net/Umbrella_Um/article/details/97271486</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Git常见报错及处理方法&quot;&gt;&lt;a href=&quot;#Git常见报错及处理方法&quot; class=&quot;headerlink&quot; title=&quot;Git常见报错及处理方法&quot;&gt;&lt;/a&gt;Git常见报错及处理方法&lt;/h2&gt;&lt;h5 id=&quot;一、如果输入-git-remote-add-ori
      
    
    </summary>
    
    
      <category term="Git" scheme="https://gkm0120.github.io/categories/Git/"/>
    
    
      <category term="git" scheme="https://gkm0120.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>搭建属于自己的hexo+github博客</title>
    <link href="https://gkm0120.github.io/2020/03/15/%E6%90%AD%E5%BB%BA%E5%B1%9E%E4%BA%8E%E8%87%AA%E5%B7%B1%E7%9A%84hexo+github%E5%8D%9A%E5%AE%A2/"/>
    <id>https://gkm0120.github.io/2020/03/15/%E6%90%AD%E5%BB%BA%E5%B1%9E%E4%BA%8E%E8%87%AA%E5%B7%B1%E7%9A%84hexo+github%E5%8D%9A%E5%AE%A2/</id>
    <published>2020-03-15T06:24:06.000Z</published>
    <updated>2020-03-21T02:03:06.997Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、node安装"><a href="#一、node安装" class="headerlink" title="一、node安装"></a>一、node安装</h2><div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;"><iframe src="//player.bilibili.com/player.html?aid=24897960&cid=42007944&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="position: absolute; width: 100%; height: 100%; Left: 0; top: 0;" ></iframe></div><hr><h3 id="bilibili链接"><a href="#bilibili链接" class="headerlink" title="bilibili链接"></a>bilibili链接</h3><p><a href="https://www.bilibili.com/video/av24897960/" target="_blank" rel="noopener">https://www.bilibili.com/video/av24897960/</a></p><h2 id="二、github注册"><a href="#二、github注册" class="headerlink" title="二、github注册"></a>二、github注册</h2><div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;"><iframe src="//player.bilibili.com/player.html?aid=24897960&cid=42007695&page=2" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="position: absolute; width: 100%; height: 100%; Left: 0; top: 0;" ></iframe></div><hr><h3 id="bilibili链接-1"><a href="#bilibili链接-1" class="headerlink" title="bilibili链接"></a>bilibili链接</h3><p><a href="https://www.bilibili.com/video/av24897960/?p=2" target="_blank" rel="noopener">https://www.bilibili.com/video/av24897960/?p=2</a></p><h2 id="三、gitforwin安装"><a href="#三、gitforwin安装" class="headerlink" title="三、gitforwin安装"></a>三、gitforwin安装</h2><div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;"><iframe src="//player.bilibili.com/player.html?aid=24897960&cid=42007693&page=3" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="position: absolute; width: 100%; height: 100%; Left: 0; top: 0;" ></iframe></div><hr><h3 id="bilibili链接-2"><a href="#bilibili链接-2" class="headerlink" title="bilibili链接"></a>bilibili链接</h3><p><a href="https://www.bilibili.com/video/av24897960/?p=3" target="_blank" rel="noopener">https://www.bilibili.com/video/av24897960/?p=3</a></p><h2 id="四、githubSHH配置"><a href="#四、githubSHH配置" class="headerlink" title="四、githubSHH配置"></a>四、githubSHH配置</h2><div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;"><iframe src="//player.bilibili.com/player.html?aid=24897960&cid=42007735&page=4" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="position: absolute; width: 100%; height: 100%; Left: 0; top: 0;" ></iframe></div><hr><h3 id="bilibili链接-3"><a href="#bilibili链接-3" class="headerlink" title="bilibili链接"></a>bilibili链接</h3><p><a href="https://www.bilibili.com/video/av24897960/?p=4" target="_blank" rel="noopener">https://www.bilibili.com/video/av24897960/?p=4</a></p><h2 id="五、hexo本地使用"><a href="#五、hexo本地使用" class="headerlink" title="五、hexo本地使用"></a>五、hexo本地使用</h2><div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;"><iframe src="//player.bilibili.com/player.html?aid=24897960&cid=42007773&page=5" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="position: absolute; width: 100%; height: 100%; Left: 0; top: 0;" ></iframe></div><hr><h3 id="bilibili链接-4"><a href="#bilibili链接-4" class="headerlink" title="bilibili链接"></a>bilibili链接</h3><p><a href="https://www.bilibili.com/video/av24897960/?p=5" target="_blank" rel="noopener">https://www.bilibili.com/video/av24897960/?p=5</a></p><h2 id="六、sublime安装"><a href="#六、sublime安装" class="headerlink" title="六、sublime安装"></a>六、sublime安装</h2><div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;"><iframe src="//player.bilibili.com/player.html?aid=24897960&cid=42008078&page=6" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="position: absolute; width: 100%; height: 100%; Left: 0; top: 0;" ></iframe></div><hr><h3 id="bilibili链接-5"><a href="#bilibili链接-5" class="headerlink" title="bilibili链接"></a>bilibili链接</h3><p><a href="https://www.bilibili.com/video/av24897960/?p=6" target="_blank" rel="noopener">https://www.bilibili.com/video/av24897960/?p=6</a></p><h2 id="七、hexo发布到github"><a href="#七、hexo发布到github" class="headerlink" title="七、hexo发布到github"></a>七、hexo发布到github</h2><div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;"><iframe src="//player.bilibili.com/player.html?aid=24897960&cid=42007849&page=7" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="position: absolute; width: 100%; height: 100%; Left: 0; top: 0;" ></iframe></div><hr><h3 id="bilibili链接-6"><a href="#bilibili链接-6" class="headerlink" title="bilibili链接"></a>bilibili链接</h3><p><a href="https://www.bilibili.com/video/av24897960/?p=7" target="_blank" rel="noopener">https://www.bilibili.com/video/av24897960/?p=7</a></p><h2 id="八、hexo主题预览"><a href="#八、hexo主题预览" class="headerlink" title="八、hexo主题预览"></a>八、hexo主题预览</h2><div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;"><iframe src="//player.bilibili.com/player.html?aid=24897960&cid=42007872&page=8" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="position: absolute; width: 100%; height: 100%; Left: 0; top: 0;" ></iframe></div><hr><h3 id="bilibili链接-7"><a href="#bilibili链接-7" class="headerlink" title="bilibili链接"></a>bilibili链接</h3><p><a href="https://www.bilibili.com/video/av24897960/?p=8" target="_blank" rel="noopener">https://www.bilibili.com/video/av24897960/?p=8</a></p><h2 id="九、hexo主题使用"><a href="#九、hexo主题使用" class="headerlink" title="九、hexo主题使用"></a>九、hexo主题使用</h2><div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;"><iframe src="//player.bilibili.com/player.html?aid=24897960&cid=42007766&page=9" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="position: absolute; width: 100%; height: 100%; Left: 0; top: 0;" ></iframe></div><hr><h3 id="bilibili链接-8"><a href="#bilibili链接-8" class="headerlink" title="bilibili链接"></a>bilibili链接</h3><p><a href="https://www.bilibili.com/video/av24897960/?p=9" target="_blank" rel="noopener">https://www.bilibili.com/video/av24897960/?p=9</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、node安装&quot;&gt;&lt;a href=&quot;#一、node安装&quot; class=&quot;headerlink&quot; title=&quot;一、node安装&quot;&gt;&lt;/a&gt;一、node安装&lt;/h2&gt;
&lt;div style=&quot;position: relative; width: 100%; hei
      
    
    </summary>
    
    
      <category term="Hexo" scheme="https://gkm0120.github.io/categories/Hexo/"/>
    
    
      <category term="hexo" scheme="https://gkm0120.github.io/tags/hexo/"/>
    
      <category term="github" scheme="https://gkm0120.github.io/tags/github/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://gkm0120.github.io/2020/03/15/hello-world/"/>
    <id>https://gkm0120.github.io/2020/03/15/hello-world/</id>
    <published>2020-03-15T02:09:20.288Z</published>
    <updated>2020-03-18T05:19:15.946Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Hello-Hexo"><a href="#Hello-Hexo" class="headerlink" title="Hello Hexo"></a>Hello Hexo</h2><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="bash">$ hexo new &quot;My New Post&quot;</code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
    
  </entry>
  
</feed>
